<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Reverse Engineering Hi-Hive Community | Yii Kuo Chong</title>
<meta name=keywords content="react-native,android,javascript,reverse-engineering"><meta name=description content="During COVID-19, my university debuted an attendance tracking called Hi-Hive Community. A lecturer would present a QR code, and the students will scan it to take attendance.
After using the application for a few years, I noticed that it was too bloated with unnecessary features, it&rsquo;s not very responsive, and important items are buried in unending levels of menus.
Thus, I have the idea of rebuilding the application using Kotlin, Jetpack Compose, and more modern UI frameworks."><meta name=author content="Yii Kuo Chong"><link rel=canonical href=https://yiikuochong.com/posts/reverse-engineering-hi-hive-community/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://yiikuochong.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yiikuochong.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yiikuochong.com/favicon-32x32.png><link rel=apple-touch-icon href=https://yiikuochong.com/apple-touch-icon.png><link rel=mask-icon href=https://yiikuochong.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-J2N6RFYFZH"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J2N6RFYFZH",{anonymize_ip:!1})}</script><meta property="og:title" content="Reverse Engineering Hi-Hive Community"><meta property="og:description" content="During COVID-19, my university debuted an attendance tracking called Hi-Hive Community. A lecturer would present a QR code, and the students will scan it to take attendance.
After using the application for a few years, I noticed that it was too bloated with unnecessary features, it&rsquo;s not very responsive, and important items are buried in unending levels of menus.
Thus, I have the idea of rebuilding the application using Kotlin, Jetpack Compose, and more modern UI frameworks."><meta property="og:type" content="article"><meta property="og:url" content="https://yiikuochong.com/posts/reverse-engineering-hi-hive-community/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-09T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-09T00:00:00+00:00"><meta property="og:site_name" content="Yii Kuo Chong Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reverse Engineering Hi-Hive Community"><meta name=twitter:description content="During COVID-19, my university debuted an attendance tracking called Hi-Hive Community. A lecturer would present a QR code, and the students will scan it to take attendance.
After using the application for a few years, I noticed that it was too bloated with unnecessary features, it&rsquo;s not very responsive, and important items are buried in unending levels of menus.
Thus, I have the idea of rebuilding the application using Kotlin, Jetpack Compose, and more modern UI frameworks."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yiikuochong.com/posts/"},{"@type":"ListItem","position":3,"name":"Reverse Engineering Hi-Hive Community","item":"https://yiikuochong.com/posts/reverse-engineering-hi-hive-community/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reverse Engineering Hi-Hive Community","name":"Reverse Engineering Hi-Hive Community","description":"During COVID-19, my university debuted an attendance tracking called Hi-Hive Community. A lecturer would present a QR code, and the students will scan it to take attendance.\nAfter using the application for a few years, I noticed that it was too bloated with unnecessary features, it\u0026rsquo;s not very responsive, and important items are buried in unending levels of menus.\nThus, I have the idea of rebuilding the application using Kotlin, Jetpack Compose, and more modern UI frameworks.","keywords":["react-native","android","javascript","reverse-engineering"],"articleBody":"During COVID-19, my university debuted an attendance tracking called Hi-Hive Community. A lecturer would present a QR code, and the students will scan it to take attendance.\nAfter using the application for a few years, I noticed that it was too bloated with unnecessary features, it’s not very responsive, and important items are buried in unending levels of menus.\nThus, I have the idea of rebuilding the application using Kotlin, Jetpack Compose, and more modern UI frameworks.\nTo do so, I first needed to figure how the API works.\nPreliminary Analysis Through regular usage, I suspected that it uses some kind of web/mobile hybrid framework.\nSome symptoms I’ve noticed are:\nSlow and slightly off user interface - There will be slight delays when tapping on elements, animation is slow, and low frame rates at times. Lack of uniformity in the components - A lot of the components seems custom made. There are a mix of native elements with custom ones. Existence of web-view pages - Some of the functions are loaded through webview. All in all it feels like using a website. My gut feelings tell me that it’s a web/mobile hybrid framework. Most likely using React Native.\nDissecting the Application The only method to really confirm this is by cracking it open and have a look at the internals. Here, I will be using version 2.3.1 of the application downloaded from ApkPure.\nUnpacking the .apk I unpacked the .apk using jadx and immediately there are telltale signs of React Native.\nFor example, this image below shows configuration for a react native push notification library.\nWhich upon further investigation, it appears that this was the library used: https://github.com/zo0r/react-native-push-notification. It’s a React Native library.\nChecking for presence of index.android.bundle Furthermore, there is also presence of index.android.bundle as seen below.\nThe index.android.bundle contains compiled and bundled JavaScript code for the application. Only React Native bundles this.\nDisassembling Hermes Bytecode Immediately, I tried to open the bundle using a text editor but it showed an error.\nAfter a google search, I found out that Hermes VM is the default compilation target for more recent versions of React Native. Which is confirmed using the file command:\nFortunately, P1 Security released a tool to disassemble, and decompile Hermes bytecodes.\nUsing the tool (hermes-dec), I disassembled the Hermes bytecode into somewhat readable pseudo-javascript.\nHowever this is still super unreadable, due to it being converted from javascript to obfuscated javascript to hermes bytecode to decompiled WASM to javascript pseudocode.\nThis meant that it’s a “readable” version of the WASM instructions, not how the original code is structured.\nIdeally, I want to get the version of the application that converted javascript to obfuscated javascript which should be more readable, and actually represent the original code.\nBack to the square one and cracking an older version The hermes-dec project README states that React Native only started targetting the Hermes VM by default after React Native v0.70.\nI thought, what if the targetting of Hermes VM isn’t actually on purpose by the developer? So I grabbed version 1.0.2 of the application which was released before React Native v0.70, and cracked it open.\nAs predicted! The index.android.bundle file is only obfuscated Javascript, not Hermes bytecode!\nThis is a more readable version of the index.android.bundle file compared to the one from version 2.3.1, not by much but it’s still better than nothing.\nWhat this means is that I now have a base from which to reverse engineer the API used by the application.\nReverse engineering and mapping the API After a bit of searching, I found the following parts. It seems to be an object containing all the API domain, and paths.\nNOTE: Through comparing v1.0.2 and v2.3.1, I found out that API_DOMAIN is not pointing to www.silverlakemobility.com anymore, it is now pointing to www.hi-hive.com.\nTo implement the application, I only need to figure out some of the endpoints.\nThe API endpoints relevant to us are:\nAuthentication Listing classes, and attendance Scanning QR codes With these, I can start mapping the needed endpoints and figure out what to pass to it.\nCracking the authentication method Looking through the rest, I found some snippets that shows how the API is being used. The snippet is the callback function for the “Login” button when it’s pressed on the login page.\nIt seems to be a bunch of async functions, and essentially what it does is:\nLoads a Firebase Cloud Messaging (FCM) token from local storage. Then use the token to encrypt the password using the convertPBEWithMD5AndDES function. Then pass the resulting encrypted password as part of the payload. The Login API Call The application then calls the login endpoint with the following JSON payload structure:\nPOST https://www.hi-hive.com/chat/api/preLogin/login\n{ \"userId\": \"your user email\", \"password\": \"encrypted version of your password\", \"os\": \"Ios or Android\", \"token\": \"The FCM token used to encrypt the password.\" } I suspect what happens here is that there was a requirement to not send passwords over the internet in plain text even when secured by SSL.\nThe token is then sent alongside the password, which I assume is used to decrypt it, and used to authenticate that the password was encrypted with a token related with the developer.\nRoadblock to putting together a 3rd party library This puts a big roadblock on our goal. What effectively happens in the end is that the login method is made a lot harder to reverse engineer since you have to somehow generated FCM token.\nOne method to solve this is to reverse engineer Google’s FCM library, then figure out if it’s possible to generate legit FCM tokens, and then check if authentication would work with that generated token.\nUntil then, listing classes, listing attendance, and scanning QR codes is essentially unusable. It’ll probably stay that way since I’m not very interested in reverse engineering Google’s FCM SDK, especially since I’m graduating and won’t be able to use the results myself.\nOther method (Network Monitoring) Apart from inspecting the unobfuscated code, I’ve used network monitoring to figure out the various endpoints and their needed payload which brought similar results.\nThis was achieved by:\nPreparing the application for network monitoring by: Cracking it open. Editing the AndroidManifest.xml file so that it trust user added SSL Certificates. Repacking, and installing it on a physical device. Preparing the device by installing a third party SSL Certificate from CharlesProxy. Monitoring the traffic of the device (and by proxy the application) using CharlesProxy. At the time, I was able to actually login using the tokens and encrypted password intercepted here which returned a session token, but I wasn’t able to capitalize on it due to the same problems stated before.\nConclusion All in all, although I did not go all the way with reverse engineering Google’s FCM SDK, it was an interesting experience reverse engineering a React Native application from my school.\n","wordCount":"1141","inLanguage":"en","datePublished":"2024-09-09T00:00:00Z","dateModified":"2024-09-09T00:00:00Z","author":{"@type":"Person","name":"Yii Kuo Chong"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yiikuochong.com/posts/reverse-engineering-hi-hive-community/"},"publisher":{"@type":"Organization","name":"Yii Kuo Chong","logo":{"@type":"ImageObject","url":"https://yiikuochong.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yiikuochong.com accesskey=h title="Yii Kuo Chong (Alt + H)">Yii Kuo Chong</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yiikuochong.com/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yiikuochong.com>Home</a>&nbsp;»&nbsp;<a href=https://yiikuochong.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Reverse Engineering Hi-Hive Community</h1><div class=post-meta><span title='2024-09-09 00:00:00 +0000 UTC'>September 9, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Yii Kuo Chong</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#preliminary-analysis aria-label="Preliminary Analysis">Preliminary Analysis</a></li><li><a href=#dissecting-the-application aria-label="Dissecting the Application">Dissecting the Application</a><ul><li><a href=#unpacking-the-apk aria-label="Unpacking the .apk">Unpacking the .apk</a></li><li><a href=#checking-for-presence-of-indexandroidbundle aria-label="Checking for presence of index.android.bundle">Checking for presence of index.android.bundle</a></li><li><a href=#disassembling-hermes-bytecode aria-label="Disassembling Hermes Bytecode">Disassembling Hermes Bytecode</a></li><li><a href=#back-to-the-square-one-and-cracking-an-older-version aria-label="Back to the square one and cracking an older version">Back to the square one and cracking an older version</a></li></ul></li><li><a href=#reverse-engineering-and-mapping-the-api aria-label="Reverse engineering and mapping the API">Reverse engineering and mapping the API</a><ul><li><a href=#cracking-the-authentication-method aria-label="Cracking the authentication method">Cracking the authentication method</a><ul><li><a href=#the-login-api-call aria-label="The Login API Call">The Login API Call</a></li></ul></li><li><a href=#roadblock-to-putting-together-a-3rd-party-library aria-label="Roadblock to putting together a 3rd party library">Roadblock to putting together a 3rd party library</a></li></ul></li><li><a href=#other-method-network-monitoring aria-label="Other method (Network Monitoring)">Other method (Network Monitoring)</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>During COVID-19, my university debuted an attendance tracking called Hi-Hive Community. A lecturer would present a QR code, and the students will scan it to take attendance.</p><p>After using the application for a few years, I noticed that it was too bloated with unnecessary features, it&rsquo;s not very responsive, and important items are buried in unending levels of menus.</p><p>Thus, I have the idea of rebuilding the application using Kotlin, Jetpack Compose, and more modern UI frameworks.</p><p>To do so, I first needed to figure how the API works.</p><h1 id=preliminary-analysis>Preliminary Analysis<a hidden class=anchor aria-hidden=true href=#preliminary-analysis>#</a></h1><p>Through regular usage, I suspected that it uses some kind of web/mobile hybrid framework.</p><p>Some symptoms I&rsquo;ve noticed are:</p><ol><li><strong>Slow and slightly off user interface</strong> - There will be slight delays when tapping on elements, animation is slow, and low frame rates at times.</li><li><strong>Lack of uniformity in the components</strong> - A lot of the components seems custom made. There are a mix of native elements with custom ones.</li><li><strong>Existence of web-view pages</strong> - Some of the functions are loaded through webview.</li></ol><p>All in all it <em>feels</em> like using a website. My gut feelings tell me that it&rsquo;s a web/mobile hybrid framework. Most likely using React Native.</p><h1 id=dissecting-the-application>Dissecting the Application<a hidden class=anchor aria-hidden=true href=#dissecting-the-application>#</a></h1><p>The only method to really confirm this is by cracking it open and have a look at the internals. Here, I will be using version <code>2.3.1</code> of the application downloaded from <a href=https://apkpure.com/hi-hive-community/com.slc.hihive.community>ApkPure</a>.</p><h2 id=unpacking-the-apk>Unpacking the <code>.apk</code><a hidden class=anchor aria-hidden=true href=#unpacking-the-apk>#</a></h2><p>I unpacked the .apk using <code>jadx</code> and immediately there are telltale signs of React Native.</p><p>For example, this image below shows configuration for a react native push notification library.</p><p><img loading=lazy src=./images/reactnative_proof.png alt="Image of configuration for a React Native library" title="Image of configuration for a React Native library"></p><p>Which upon further investigation, it appears that this was the library used: <a href=https://github.com/zo0r/react-native-push-notification>https://github.com/zo0r/react-native-push-notification</a>. It&rsquo;s a React Native library.</p><h2 id=checking-for-presence-of-indexandroidbundle>Checking for presence of <code>index.android.bundle</code><a hidden class=anchor aria-hidden=true href=#checking-for-presence-of-indexandroidbundle>#</a></h2><p>Furthermore, there is also presence of <code>index.android.bundle</code> as seen below.</p><p><img loading=lazy src=./images/reactnative_bundle_proof.png alt="Image of index.android.bundle in file structure" title="Image of index.android.bundle in file structure"></p><p>The <code>index.android.bundle</code> contains compiled and bundled JavaScript code for the application. Only React Native bundles this.</p><h2 id=disassembling-hermes-bytecode>Disassembling Hermes Bytecode<a hidden class=anchor aria-hidden=true href=#disassembling-hermes-bytecode>#</a></h2><p>Immediately, I tried to open the bundle using a text editor but it showed an error.</p><p><img loading=lazy src=./images/cannot_open_bundle.png alt="Image of cannot open bundle" title="Image of cannot open bundle"></p><p>After a google search, I found out that Hermes VM is the default compilation target for more recent versions of React Native. Which is confirmed using the <code>file</code> command:</p><p><img loading=lazy src=./images/file_command_result.png alt="Image of file tool showing result" title="Image of file tool showing result"></p><p>Fortunately, <a href=https://www.p1sec.com/blog/releasing-hermes-dec-an-open-source-disassembler-and-decompiler-for-the-react-native-hermes-bytecode>P1 Security</a> released a tool to disassemble, and decompile Hermes bytecodes.</p><p>Using the tool (<a href=https://github.com/P1sec/hermes-dec/>hermes-dec</a>), I disassembled the Hermes bytecode into somewhat readable pseudo-javascript.</p><p><img loading=lazy src=./images/not_so_readable_pseudocode.png alt="Image of not so readable pseudocode" title="Image of not so readable pseudocode"></p><p>However this is still super unreadable, due to it being converted from <code>javascript</code> to <code>obfuscated javascript</code> to <code>hermes bytecode</code> to <code>decompiled WASM</code> to <code>javascript pseudocode</code>.</p><p>This meant that it&rsquo;s a &ldquo;readable&rdquo; version of the WASM instructions, not how the original code is structured.</p><p>Ideally, I want to get the version of the application that converted <code>javascript</code> to <code>obfuscated javascript</code> which should be more readable, and actually represent the original code.</p><h2 id=back-to-the-square-one-and-cracking-an-older-version>Back to the square one and cracking an older version<a hidden class=anchor aria-hidden=true href=#back-to-the-square-one-and-cracking-an-older-version>#</a></h2><p>The <code>hermes-dec</code> project README states that React Native only started targetting the Hermes VM by default after React Native v0.70.</p><p>I thought, <em>what if the targetting of Hermes VM isn&rsquo;t actually on purpose by the developer?</em> So I grabbed version <code>1.0.2</code> of the application which was released before React Native v0.70, and cracked it open.</p><p>As predicted! The <code>index.android.bundle</code> file is only obfuscated Javascript, not Hermes bytecode!</p><p><img loading=lazy src=./images/more_readable_bundle.png alt="Image of more readable bundle" title="Image of more readable bundle"></p><p>This is a more readable version of the <code>index.android.bundle</code> file compared to the one from version <code>2.3.1</code>, not by much but it&rsquo;s still better than nothing.</p><p>What this means is that I now have a base from which to reverse engineer the API used by the application.</p><h1 id=reverse-engineering-and-mapping-the-api>Reverse engineering and mapping the API<a hidden class=anchor aria-hidden=true href=#reverse-engineering-and-mapping-the-api>#</a></h1><p>After a bit of searching, I found the following parts. It seems to be an object containing all the API domain, and paths.</p><p><img loading=lazy src=./images/api_constants.png alt="Image of API constants" title="Image of API constants"></p><blockquote><p>NOTE: Through comparing v1.0.2 and v2.3.1, I found out that <code>API_DOMAIN</code> is not pointing to <code>www.silverlakemobility.com</code> anymore, it is now pointing to <code>www.hi-hive.com</code>.</p></blockquote><p>To implement the application, I only need to figure out some of the endpoints.</p><p>The API endpoints relevant to us are:</p><ul><li>Authentication</li><li>Listing classes, and attendance</li><li>Scanning QR codes</li></ul><p>With these, I can start mapping the needed endpoints and figure out what to pass to it.</p><h2 id=cracking-the-authentication-method>Cracking the authentication method<a hidden class=anchor aria-hidden=true href=#cracking-the-authentication-method>#</a></h2><p>Looking through the rest, I found some snippets that shows how the API is being used. The snippet is the callback function for the &ldquo;Login&rdquo; button when it&rsquo;s pressed on the login page.</p><p><img loading=lazy src=./images/firebase_restriction.png alt="Image of firebase restriction" title="Image of firebase restriction"></p><p>It seems to be a bunch of async functions, and essentially what it does is:</p><ol><li>Loads a Firebase Cloud Messaging (FCM) token from local storage.</li><li>Then use the token to encrypt the password using the <code>convertPBEWithMD5AndDES</code> function.</li><li>Then pass the resulting encrypted password as part of the payload.</li></ol><h3 id=the-login-api-call>The Login API Call<a hidden class=anchor aria-hidden=true href=#the-login-api-call>#</a></h3><p>The application then calls the login endpoint with the following JSON payload structure:</p><p><code>POST https://www.hi-hive.com/chat/api/preLogin/login</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;userId&#34;</span>: <span style=color:#e6db74>&#34;your user email&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;password&#34;</span>: <span style=color:#e6db74>&#34;encrypted version of your password&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;os&#34;</span>: <span style=color:#e6db74>&#34;Ios or Android&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;token&#34;</span>: <span style=color:#e6db74>&#34;The FCM token used to encrypt the password.&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I suspect what happens here is that there was a requirement to not send passwords over the internet in plain text even when secured by SSL.</p><p>The token is then sent alongside the password, which I assume is used to decrypt it, and used to authenticate that the password was encrypted with a token related with the developer.</p><h2 id=roadblock-to-putting-together-a-3rd-party-library>Roadblock to putting together a 3rd party library<a hidden class=anchor aria-hidden=true href=#roadblock-to-putting-together-a-3rd-party-library>#</a></h2><p>This puts a big roadblock on our goal. What effectively happens in the end is that the login method is made a lot harder to reverse engineer since you have to somehow generated FCM token.</p><p>One method to solve this is to reverse engineer Google&rsquo;s FCM library, then figure out if it&rsquo;s possible to generate legit FCM tokens, and then check if authentication would work with that generated token.</p><p>Until then, listing classes, listing attendance, and scanning QR codes is essentially unusable. It&rsquo;ll probably stay that way since I&rsquo;m not very interested in reverse engineering Google&rsquo;s FCM SDK, especially since I&rsquo;m graduating and won&rsquo;t be able to use the results myself.</p><h1 id=other-method-network-monitoring>Other method (Network Monitoring)<a hidden class=anchor aria-hidden=true href=#other-method-network-monitoring>#</a></h1><p>Apart from inspecting the unobfuscated code, I&rsquo;ve used network monitoring to figure out the various endpoints and their needed payload which brought similar results.</p><p>This was achieved by:</p><ol><li>Preparing the application for network monitoring by:<ul><li>Cracking it open.</li><li>Editing the <code>AndroidManifest.xml</code> file so that it trust user added SSL Certificates.</li><li>Repacking, and installing it on a physical device.</li></ul></li><li>Preparing the device by installing a third party SSL Certificate from CharlesProxy.</li><li>Monitoring the traffic of the device (and by proxy the application) using <a href=https://www.charlesproxy.com/>CharlesProxy</a>.</li></ol><p>At the time, I was able to actually login using the tokens and encrypted password intercepted here which returned a session token, but I wasn&rsquo;t able to capitalize on it due to the same problems stated before.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>All in all, although I did not go all the way with reverse engineering Google&rsquo;s FCM SDK, it was an interesting experience reverse engineering a React Native application from my school.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yiikuochong.com/tags/react-native/>react-native</a></li><li><a href=https://yiikuochong.com/tags/android/>android</a></li><li><a href=https://yiikuochong.com/tags/javascript/>javascript</a></li><li><a href=https://yiikuochong.com/tags/reverse-engineering/>reverse-engineering</a></li></ul><nav class=paginav><a class=prev href=https://yiikuochong.com/posts/my-experience-with-topcoder-malaysia/><span class=title>« Prev</span><br><span>My experience with TopCoder Malaysia</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yiikuochong.com>Yii Kuo Chong</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>